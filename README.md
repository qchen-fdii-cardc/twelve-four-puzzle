# Twelve-Four Puzzle（24 点求解器）

这是一个用来玩“24 点”小游戏的程序。运行时它会随机选出四张牌（牌面取值 1 到 13），然后尝试用加减乘除以及不同的括号组合把这些数算成 24。程序会把抽到的牌以及所有找到的表达式写入到仓库下的日志文件 `log/24_game_log.txt`，如果没有找到可行表达式，也会写一条提示性信息。

要运行这个程序，你需要安装 Rust（推荐通过 rustup 安装最新稳定版）。在仓库目录下执行 `cargo build` 可以编译项目，执行 `cargo run` 会编译并运行一次：程序会在启动时自动创建 `log/` 目录（如果不存在），生成一手随机牌、求解并把结果追加写入日志，运行结束后程序退出。想要进行发布构建可以用 `cargo build --release`，这样会生成更快的二进制。

实现上是暴力穷举，但这是一个简单清晰且对四个数问题完全可行的做法。程序先枚举四张牌的所有排列，因为数字顺序会影响计算结果；对每个排列尝试所有三个位的运算符组合（每位 4 种运算，总共 4^3 种）；同时针对四个操作数存在的五种不同括号形态分别计算。把排列、运算符组合与括号形态三层都枚举一遍，能保证不会漏掉任何合法表达式。

关于数值稳定性方面的处理比较简单：所有中间计算使用 `f64`，判断是否等于目标 24 时采用一个小的容差 `EPSILON = 1e-6`。遇到除法且分母接近 0 的情况，程序不会崩溃，而是把该计算路径视为不可行（对应函数返回 `None`），然后继续枚举其它路径。这样既避免了除以零的错误，也减少了因为浮点数微小误差而出现的假阳性。

代码结构上我倾向于把复杂逻辑拆成小的纯函数，便于阅读和测试。例如，排列生成由 `permutations(nums: &[f64]) -> Vec<Vec<f64>>` 实现，采用递归把每个元素当作头部，把剩余元素的排列拼接起来；五种括号结构则各自实现为 `try_struct1` 到 `try_struct5`，每个函数接受当前数列和三个运算符，返回 `Option<String>`，只有在该结构计算结果等于 24 时返回表达式字符串，其他情况返回 `None`。中间计算使用 `apply_op`，它也是返回 `Option<f64>`，当运算有效时返回 `Some(value)`；遇到非法除法则返回 `None`，利用 `Option` 与 `and_then` 能把这些可能失败的步骤串联成简洁的代码。

从语言特性角度来看，这个项目用到了几项常见的 Rust 习惯用法。函数参数常用借用（例如 `&[f64]`），以避免不必要的克隆；`Option<T>` 被用来表示“这条计算路径是否可行”；大量使用迭代器链（`iter`, `map`, `flat_map` 等）和闭包，让数据处理显得更像流水线；`HashSet<String>` 用于去重最终表达式，保证输出没有重复项；文件操作通过 `std::fs::create_dir_all` 和 `OpenOptions` 来确保目录存在并以追加模式写日志。

下面给出常用命令，便于快速上手和调试：

```bash
# 如果尚未安装 Rust：
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 开发时运行：
cargo build
cargo run

# release 构建：
cargo build --release
cargo run --release

# 运行后查看日志（Linux）：
tail -n 40 log/24_game_log.txt
```

运行一次后，日志中会包含类似下面的条目：

```
[2025-11-18 12:34:56] Cards: [9, 13, 12, 6]
Solutions:
(9 * (13 - (12 / 6)))
... (其它表达式)
--------------------
```

如果你想继续扩展项目，有几条比较自然的方向可以考虑。比如把 `permutations` 的示例改成 doctest 并通过 `cargo test --doc` 验证，把更多单元测试补到 `apply_op` 和 `try_struct*`，或者让程序支持命令行参数（例如 `--count N` 指定运行多少手，或者 `--loop` 一直运行并在收到 SIGINT 时优雅退出）。如果目标是处理更多数字（超过 4 个），那就需要引入剪枝或改用更高效的算法，而不是纯暴力枚举。

